

--========================================================
--                  TUTORIAL CHECK SYSTEM                 
--========================================================

print("üîç Checking Tutorial Status...")

local function getTutorialStatus()
    local success, status = pcall(function()
        return game:GetService("Players").LocalPlayer.Data.Tutorial.PrimaryStage.Value
    end)
    if success then
        return status
    end
    return nil
end

local function waitForTutorialComplete()
    while true do
        local status = getTutorialStatus()
        
        if status == "Complete" then
            print("‚úÖ Tutorial Complete! Starting Auto Farm...")
            return true
        else
            print("‚è≥ Tutorial Not Complete (Status: " .. tostring(status) .. ")")
            print("üîÑ Running Tutorial Skip Script...")

            local success, err = pcall(function()
                getgenv().Configs = {
                ["TargetWorld"] = "Shinrin",
                ["SelectedDragon"] = "1"
            }

            loadstring(request({Url="https://lunar-rest-api.vercel.app/script/AutoDAWorldUnlocker",Method="GET"}).Body)()
            end)
            
            if not success then
                warn("‚ùå Tutorial Script Error: " .. tostring(err))
            end
            
            print("‚è∏Ô∏è Waiting 10 seconds before checking again...")
            task.wait(10)
        end
    end
end

-- ‡πÄ‡∏ä‡πá‡∏Ñ tutorial ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏≤‡∏£‡πå‡∏°
waitForTutorialComplete()

print("üöÄ Tutorial check passed! Initializing farm system...")
task.wait(2)


--========================================================--
--                    ANTI-AFK SYSTEM                     
--========================================================--

print("üõ°Ô∏è Initializing Anti-AFK System...")

-- ‡∏õ‡∏¥‡∏î Idled Connection
for _, v in ipairs(getconnections(game:GetService("Players").LocalPlayer.Idled)) do
    v:Disable()
end

print("‚úÖ Idled connections disabled")

-- Hook Metatable ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏•‡πá‡∏≠‡∏Å AFK Events
local success = pcall(function()
    local mt = getrawmetatable(game)
    setreadonly(mt, false)
    
    local SuspiciousEvents = {
        "AFKEvent",
        "GameAnalyticsError"
    }
    
    local namecall = mt.__namecall
    mt.__namecall = newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if method == "FireServer" and table.find(SuspiciousEvents, tostring(self)) then
            return -- ‡∏ö‡∏•‡πá‡∏≠‡∏Å AFK event
        end
        
        return namecall(self, table.unpack(args))
    end)
    
    setreadonly(mt, true)
end)

if success then
    print("‚úÖ Anti-AFK Metatable Hook Active")
else
    warn("‚ö†Ô∏è Anti-AFK Hook Failed (Executor may not support)")
end

-- Anti-Kick Loop
task.spawn(function()
    while true do
        task.wait(60) -- ‡∏ó‡∏∏‡∏Å 1 ‡∏ô‡∏≤‡∏ó‡∏µ
        
        pcall(function()
            -- ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
            local VirtualUser = game:GetService("VirtualUser")
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end)
    end
end)

print("‚úÖ Anti-AFK System Active!")
print("‚úÖ You will NOT be kicked for being AFK")




--========================================================--
--                    MAIN FARM SCRIPT                    
--========================================================--

if not getgenv then getgenv = function() return _G end end
local env = getgenv()

if not env.DragonFarmConfig then
    env.DragonFarmConfig = {
        DRAGON_NAME = "Saurium",
        ATTACK_DELAY = 0.05,
        TELEPORT_WAIT = 0.2,
        MOVEMENT_SPEED = 0.5,
        AUTO_COLLECT_DELAY = 5,
        TELEPORT_OFFSET = Vector3.new(0, 4, 0)
    }
end

local CONFIG = env.DragonFarmConfig
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local player = Players.LocalPlayer

print("üåç Starting Multi-World Auto Farm System...")

--========================================================--
--                    WORLD DEFINITIONS                   
--========================================================--

local WORLDS = {
    {name = "Lobby", placeId = 3475397644, order = 1},
    {name = "Grassland", placeId = 3475419198, order = 2},
    {name = "Jungle", placeId = 3475422608, order = 3},
    {name = "Volcano", placeId = 3487210751, order = 4},
    {name = "Tundra", placeId = 3623549100, order = 5},
    {name = "Ocean", placeId = 3737848045, order = 6},
    {name = "Desert", placeId = 3752680052, order = 7},
    {name = "Fantasy", placeId = 4174118306, order = 8},
    {name = "Toxic", placeId = 4728805070, order = 9},
    {name = "Prehistoric", placeId = 4869039553, order = 10}
}

local WORLD_POSITIONS = {
    Grassland = {
        Treasure = {
            Vector3.new(-1516.8, 141.4, 508.5),
            Vector3.new(-136.8, 213.7, -1421.4),
            Vector3.new(-587.6, 758.7, -761.0),
            Vector3.new(-153.5, 123.5, -1348.7),
            Vector3.new(-1325.9, 102.3, -210.1),
            Vector3.new(1363.1, 305.7, -1077.7),
            Vector3.new(-1122.2, 581.0, 1481.1),
            Vector3.new(586.4, 97.0, 298.6),
            Vector3.new(-1333.0, 137.7, 1308.5),
            Vector3.new(1278.6, 182.2, 435.1),
            Vector3.new(1200.1, 341.6, 335.2),
            Vector3.new(-781.9, 122.6, -263.2),
            Vector3.new(850.2, 94.0, -1018.6),
            Vector3.new(-840.0, 205.7, 1427.8),
            Vector3.new(-383.7, 436.5, 1746.4)
        },
        Patrol = {
            Vector3.new(-266, 467, -394),
            Vector3.new(1757, 783, 672),
            Vector3.new(1420, 319, -1409),
            Vector3.new(1922, 620, -2566)
        }
    },
    Jungle = {
        Treasure = {
            Vector3.new(102.6, -122.3, -263.0),
            Vector3.new(-90.0, -86.3, 671.3),
            Vector3.new(585.1, -82.3, 526.4),
            Vector3.new(891.5, 5.6, 392.2),
            Vector3.new(-208.6, 9.7, 896.5),
            Vector3.new(-704.2, 1.7, 700.2),
            Vector3.new(1396.4, 84.5, -79.5),
            Vector3.new(-671.6, -54.5, -545.9),
            Vector3.new(-517.4, 5.2, -890.0),
            Vector3.new(-648.6, 21.5, 846.8),
            Vector3.new(-888.6, 5.7, 251.8)
        },
        Patrol = {
            Vector3.new(-1516.8, 141.4, 508.5),
            Vector3.new(-136.8, 213.7, -1421.4),
            Vector3.new(-587.6, 758.7, -761.0)
        }
    },
    Volcano = {
        Treasure = {
            Vector3.new(782.3, 144.5, -321.9),
            Vector3.new(-703.1, 257.1, -990.3),
            Vector3.new(-2667.7, 85.4, -1070.7),
            Vector3.new(320.3, 69.1, 56.1),
            Vector3.new(-948.8, -173.1, 1180.1),
            Vector3.new(-2250.7, 72.2, 271.0),
            Vector3.new(-1300.1, -18.7, 1015.3),
            Vector3.new(1324.1, 77.7, 643.5),
            Vector3.new(-91.3, -139.6, 1352.8),
            Vector3.new(729.6, 73.2, 456.1),
            Vector3.new(-395.2, 121.7, -1059.1)
        },
        Patrol = {
            Vector3.new(-266, 467, -394),
            Vector3.new(1757, 783, 672)
        }
    },
    Tundra = {
        Treasure = {
            Vector3.new(-1155.2, 1386.7, 1389.7),
            Vector3.new(1263.9, 767.5, 663.4),
            Vector3.new(-1409.3, 1408.8, -760.8),
            Vector3.new(1028.3, 1464.7, 1287.6),
            Vector3.new(1469.5, 1625.3, 61.6),
            Vector3.new(2054.8, 2125.1, 431.7),
            Vector3.new(631.5, 1429.4, 2204.5),
            Vector3.new(1557.7, 1752.9, 436.3),
            Vector3.new(138.3, 2432.5, 1889.9),
            Vector3.new(-375.1, 2253.2, 2068.5),
            Vector3.new(889.8, 975.0, 746.9),
            Vector3.new(761.7, 1510.2, -756.9)
        },
        Patrol = {
            Vector3.new(-1155.2, 1386.7, 1389.7),
            Vector3.new(1263.9, 767.5, 663.4)
        }
    },
    Ocean = {
        Treasure = {
            Vector3.new(-97.1, -124.0, 66.4),
            Vector3.new(491.8, -15.9, 214.7),
            Vector3.new(-558.6, -121.3, 1243.2),
            Vector3.new(-875.4, -31.3, 790.6),
            Vector3.new(333.9, -270.8, -80.7),
            Vector3.new(674.9, 363.9, 512.0),
            Vector3.new(-493.6, 163.8, 576.2),
            Vector3.new(-133.7, 136.7, 48.1),
            Vector3.new(506.5, -325.3, 516.3),
            Vector3.new(113.1, 25.2, 1543.4),
            Vector3.new(194.4, 205.2, 1441.5)
        },
        Patrol = {
            Vector3.new(-97.1, -124.0, 66.4),
            Vector3.new(491.8, -15.9, 214.7)
        }
    },
    Desert = {
        Treasure = {
            Vector3.new(-1519.4, 293.7, -815.1),
            Vector3.new(-971.9, 580.1, -397.4),
            Vector3.new(-1575.0, 53.7, -1050.9),
            Vector3.new(2148.3, 260.0, -948.0),
            Vector3.new(-1608.4, 47.5, 747.3),
            Vector3.new(-23.1, 168.8, 2233.2),
            Vector3.new(96.6, 65.7, -1722.4),
            Vector3.new(407.5, 381.7, -1545.4),
            Vector3.new(841.1, 249.0, 1833.0),
            Vector3.new(1662.3, 290.8, -829.7),
            Vector3.new(2343.5, 525.8, -461.5),
            Vector3.new(534.6, 352.7, -2014.9),
            Vector3.new(-1745.0, 533.7, 416.9),
            Vector3.new(14.7, 140.4, -130.5),
            Vector3.new(-1520.6, 368.4, -2113.7)
        },
        Patrol = {
            Vector3.new(-1519.4, 293.7, -815.1),
            Vector3.new(-971.9, 580.1, -397.4)
        }
    },
    Fantasy = {
        Treasure = {
            Vector3.new(-665.9, 434.2, -1715.5),
            Vector3.new(305.4, 122.7, 427.1),
            Vector3.new(1491.7, 480.5, -2407.5),
            Vector3.new(-898.2, 63.4, 2228.6),
            Vector3.new(-654.9, 69.7, 1712.3),
            Vector3.new(1403.0, 213.7, 129.4),
            Vector3.new(2415.8, 521.3, -2637.0),
            Vector3.new(609.2, 35.4, 210.9),
            Vector3.new(-106.2, 161.6, -69.2),
            Vector3.new(-673.8, 74.9, 1073.6),
            Vector3.new(894.7, 19.0, -388.1),
            Vector3.new(48.0, 18.1, 209.6),
            Vector3.new(-1701.7, 208.2, 465.9)
        },
        Patrol = {
            Vector3.new(-665.9, 434.2, -1715.5),
            Vector3.new(305.4, 122.7, 427.1)
        }
    },
    Toxic = {
        Treasure = {
            Vector3.new(-2139.6, 256.9, -1428.5),
            Vector3.new(-1561.6, 278.4, 1401.9),
            Vector3.new(-1570.8, 302.0, -1456.3),
            Vector3.new(-2099.8, 407.3, 1050.7),
            Vector3.new(2257.2, 285.5, 331.5),
            Vector3.new(592.6, 305.1, 2322.1),
            Vector3.new(-801.4, 645.1, -1511.4),
            Vector3.new(-1141.1, 57.5, -1813.7),
            Vector3.new(-277.6, -166.1, -2208.2),
            Vector3.new(-693.2, 278.8, 2135.7),
            Vector3.new(377.7, 1153.7, -2623.6),
            Vector3.new(440.3, 113.1, 1645.5)
        },
        Patrol = {
            Vector3.new(-665.9, 434.2, -1715.5),
            Vector3.new(305.4, 122.7, 427.1)
        }
    },
    Prehistoric = {
        Treasure = {
            Vector3.new(962.8, 149.1, 1037.9),
            Vector3.new(305.2, 381.5, -88.2),
            Vector3.new(343.3, 501.5, -1122.5),
            Vector3.new(1037.5, 226.6, 889.7),
            Vector3.new(-244.8, 124.3, 9.1),
            Vector3.new(-902.9, 465.4, -855.6),
            Vector3.new(-314.7, 429.0, -603.9),
            Vector3.new(-705.3, 124.2, 311.2),
            Vector3.new(-875.6, 138.9, -1171.4),
            Vector3.new(370.1, 71.6, -204.7),
            Vector3.new(-1015.7, 388.2, -518.5),
            Vector3.new(372.2, 125.1, -785.6)
        },
        Patrol = {
            Vector3.new(-665.9, 434.2, -1715.5),
            Vector3.new(305.4, 122.7, 427.1)
        }
    }
}



local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local EquipDragonRemote = Remotes:WaitForChild("EquipDragonRemote")
local LargeDropsRemote = Remotes:WaitForChild("LargeNodeDropsRemote")
local currentDragonIndex = nil
local currentLocationIndex = 1
local lastPositionChangeTime = tick()
local CollectableNames = {"EdamameFoodModel", "KajiFruitFoodModel", "MistSudachiFoodModel"}

--========================================================--
--                   QUEST CHECK FUNCTIONS                
--========================================================--

local function checkAllQuests(worldName)
    local success, quests = pcall(function()
        local missions = player.Data.WorldMissions[worldName].Missions
        
        if worldName == "Lobby" then
            return {
                RidingRing = missions.RidingRing.Value,
                EggQuest = missions.EggQuest.Value
            }
        elseif worldName == "Grassland" then
            return {
                EggQuest = missions.EggQuest.Value,
                Harvest = missions.Harvest.Value,
                KillMobs = missions.KillMobs.Value,
                TreasureChest = missions.TreasureChest.Value
            }
        else
            return {
                EggQuest = missions.EggQuest.Value,
                Harvest = missions.Harvest.Value,
                KillMobs = missions.KillMobs.Value,
                KillBoss = missions.KillBoss.Value,
                TreasureChest = missions.TreasureChest.Value,
                SpendTime = missions.SpendTime and missions.SpendTime.Value or true
            }
        end
    end)
    
    if not success then
        return {EggQuest = false, Harvest = false, KillMobs = false, KillBoss = false, TreasureChest = false, SpendTime = false, RidingRing = false}
    end
    
    return quests
end

local function allQuestsComplete(worldName)
    local quests = checkAllQuests(worldName)
    
    if worldName == "Lobby" then
        return quests.RidingRing and quests.EggQuest
    elseif worldName == "Grassland" then
        return quests.EggQuest and quests.TreasureChest and quests.KillMobs and quests.Harvest
    else
        return quests.EggQuest and quests.TreasureChest and quests.KillMobs and quests.KillBoss and quests.Harvest
    end
end

local function printQuestStatus(worldName)
    local quests = checkAllQuests(worldName)
    print("==========================================")
    print("Quest Status: " .. worldName)
    
    if worldName == "Lobby" then
        print("  1. RidingRing:", quests.RidingRing and "OK" or "NO")
        print("  2. EggQuest:", quests.EggQuest and "OK" or "NO")
    elseif worldName == "Grassland" then
        print("  1. EggQuest:", quests.EggQuest and "OK" or "NO")
        print("  2. TreasureChest:", quests.TreasureChest and "OK" or "NO")
        print("  3. KillMobs:", quests.KillMobs and "OK" or "NO")
        print("  4. Harvest:", quests.Harvest and "OK" or "NO")
    else
        print("  1. EggQuest:", quests.EggQuest and "OK" or "NO")
        print("  2. TreasureChest:", quests.TreasureChest and "OK" or "NO")
        print("  3. KillMobs:", quests.KillMobs and "OK" or "NO")
        print("  4. KillBoss:", quests.KillBoss and "OK" or "NO")
        print("  5. Harvest:", quests.Harvest and "OK" or "NO")
    end
    print("==========================================")
end

--========================================================--
--                  TELEPORT FUNCTION                     
--========================================================--

local function TPWorld(placeId, name)
    print("==========================================")
    print("Teleporting to: " .. name)
    print("==========================================")
    pcall(function()
        Remotes.WorldTeleportRemote:InvokeServer(placeId, {})
    end)
    task.wait(10)
end

--========================================================--
--              SAFE WAIT FOR CHILD FUNCTION              
--========================================================--

local function safeWaitForChild(parent, childName, timeout)
    local success, result = pcall(function()
        return parent:WaitForChild(childName, timeout or 5)
    end)
    return success and result or nil
end

--========================================================--
--                   DRAGON FUNCTIONS                     
--========================================================--

local function GetBestDragonIndex()
    local dragonData = safeWaitForChild(player.Data, "Dragons", 5)
    if not dragonData then return nil, 0 end
    
    local bestIndex, bestLevel = nil, -1
    for _, slot in ipairs(dragonData:GetChildren()) do
        if slot.Value == CONFIG.DRAGON_NAME then
            local level = slot:FindFirstChild("Level") and slot:FindFirstChild("Level").Value or 0
            if level > bestLevel then
                bestLevel, bestIndex = level, slot.Name
            end
        end
    end
    return bestIndex, bestLevel
end

--========================================================--
--              ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏Ç‡∏µ‡πà‡∏°‡∏±‡∏á‡∏Å‡∏£‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà           
--========================================================--

local function IsPlayerSeatedOnDragon(dragonIndex)
    local success, result = pcall(function()
        local character = player.Character
        if not character then return false end

        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or not humanoid.SeatPart then return false end

        local chars = workspace:FindFirstChild("Characters")
        if not chars then return false end
        
        local playerChar = chars:FindFirstChild(player.Name)
        if not playerChar then return false end
        
        local dragonsFolder = playerChar:FindFirstChild("Dragons")
        if not dragonsFolder then return false end
        
        local dragonModel = dragonsFolder:FindFirstChild(dragonIndex)
        if not dragonModel then return false end

        return humanoid.SeatPart:IsDescendantOf(dragonModel)
    end)
    
    return success and result
end

--========================================================--
--                  ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Equip ‡∏°‡∏±‡∏á‡∏Å‡∏£                   
--========================================================--

local function EquipDragonByIndex(index)
    pcall(function()
        EquipDragonRemote:InvokeServer(index)
        print("‚ö° Equipping dragon index:", index)
    end)
end

--========================================================--
--                  ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ç‡∏µ‡πà‡∏°‡∏±‡∏á‡∏Å‡∏£                       
--========================================================--

local function SitDragon(index)
    pcall(function()
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end

        local chars = workspace:FindFirstChild("Characters")
        if not chars then return end
        
        local playerChar = chars:FindFirstChild(player.Name)
        if not playerChar then return end
        
        local dragonsFolder = playerChar:FindFirstChild("Dragons")
        if not dragonsFolder then return end
        
        local dragonModel = dragonsFolder:FindFirstChild(index)
        if not dragonModel then 
            warn("‚ùå Dragon model not found, index:", index)
            return 
        end

        local seat = dragonModel:FindFirstChildWhichIsA("Seat", true)
        if not seat then 
            warn("‚ùå Dragon has no seat")
            return 
        end

        seat:Sit(humanoid)
        print("üêâ Seated on dragon, index:", index)
    end)
end

--========================================================--
--                  AUTO REVIVE DRAGON                    
--========================================================--

local function getAutoDragon()
    local chars = workspace:FindFirstChild("Characters")
    if not chars then return nil end
    
    local playerChar = chars:FindFirstChild(player.Name)
    if not playerChar then return nil end
    
    local dragonFolder = playerChar:FindFirstChild("Dragons")
    if not dragonFolder then return nil end
    
    local dragons = dragonFolder:GetChildren()
    return #dragons > 0 and dragons[1] or nil
end

local function reviveDragon(dragonModel)
    local success, err = pcall(function()
        local dragonName = dragonModel.Name
        local data = dragonModel:FindFirstChild("Data")
        local deadFlag = data and data:FindFirstChild("Dead")

        if deadFlag and deadFlag.Value == true then
            print("üíÄ Dragon dead ‚Äî Reviving...")
            
            local remotes = safeWaitForChild(ReplicatedStorage, "Remotes", 5)
            if not remotes then return end
            
            local reviveRemote = remotes:FindFirstChild("ReviveDragonRemote")
            if reviveRemote then
                local args = { dragonName, "DragonRevivalHeart" }
                reviveRemote:InvokeServer(unpack(args))
                print("‚ù§Ô∏è Dragon revived:", dragonName)
                task.wait(1)
            end
        end
    end)
    
    if not success then
        warn("‚ùå Revive Error:", err)
    end
end

local function ensureMountedDragon()
    local dragonModel = getAutoDragon()
    if not dragonModel then 
        print("‚ö†Ô∏è No dragon found")
        return 
    end

    reviveDragon(dragonModel)

    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    local currentSeat = humanoid.SeatPart
    local currentMount = currentSeat and currentSeat:FindFirstAncestorWhichIsA("Model")

    if currentMount and currentMount:IsDescendantOf(dragonModel.Parent) then
        return
    end

    local seat = dragonModel:FindFirstChildWhichIsA("Seat", true)
    if seat and humanoid then
        seat:Sit(humanoid)
        print("ü™∂ Mounted dragon:", dragonModel.Name)

        task.wait(1)
        
        pcall(function()
            local flyBtn = safeWaitForChild(player.PlayerGui, "HUDGui", 5)
            if not flyBtn then return end
            
            flyBtn = safeWaitForChild(flyBtn, "BottomFrame", 2)
            if not flyBtn then return end
            
            flyBtn = flyBtn:FindFirstChild("CurrentDragonFrame")
            if not flyBtn then return end
            
            flyBtn = flyBtn:FindFirstChild("DragonControlsFrame")
            if not flyBtn then return end
            
            flyBtn = flyBtn:FindFirstChild("Other")
            if not flyBtn then return end
            
            flyBtn = flyBtn:FindFirstChild("Fly")
            if flyBtn and flyBtn:FindFirstChild("MouseButton1Down") then
                firesignal(flyBtn.MouseButton1Down)
                print("üõ´ Flying!")
            end
        end)
    end
end

--========================================================--
--      AUTO REMOUNT SYSTEM (‡∏ï‡∏Å‡∏à‡∏≤‡∏Å‡∏°‡∏±‡∏á‡∏Å‡∏£/Unequip)        
--========================================================--

-- Loop ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ó‡∏∏‡∏Å 1 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
task.spawn(function()
    while true do
        task.wait(1)
        
        pcall(function()
            if not currentDragonIndex then return end
            
            local character = player.Character
            if not character then return end
            
            if not IsPlayerSeatedOnDragon(currentDragonIndex) then
                warn("‚ö†Ô∏è FELL OFF DRAGON! Re-mounting immediately...")
                
                EquipDragonByIndex(currentDragonIndex)
                task.wait(0.5)
                
                SitDragon(currentDragonIndex)
                task.wait(0.5)
                
                print("‚úÖ Successfully remounted!")
            end
        end)
    end
end)

-- Loop ‡πÄ‡∏ä‡πá‡∏Ñ Humanoid.Seated Event
task.spawn(function()
    while true do
        task.wait(0.5)
        
        pcall(function()
            local character = player.Character
            if not character then return end
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if not humanoid then return end
            
            if not humanoid.SeatPart and currentDragonIndex then
                warn("üö® UNSEATED EVENT! Remounting NOW...")
                
                task.wait(0.2)
                EquipDragonByIndex(currentDragonIndex)
                task.wait(0.5)
                SitDragon(currentDragonIndex)
            end
        end)
    end
end)

--========================================================--
--          DETECT DRAGON UNEQUIP (‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å)            
--========================================================--

task.spawn(function()
    while true do
        task.wait(0.5)
        
        pcall(function()
            if not currentDragonIndex then return end
            
            local chars = workspace:FindFirstChild("Characters")
            if not chars then return end
            
            local playerChar = chars:FindFirstChild(player.Name)
            if not playerChar then return end
            
            local dragonsFolder = playerChar:FindFirstChild("Dragons")
            if not dragonsFolder then 
                warn("üö® DRAGON FOLDER MISSING! Re-equipping...")
                EquipDragonByIndex(currentDragonIndex)
                task.wait(1)
                SitDragon(currentDragonIndex)
                return
            end
            
            local dragonModel = dragonsFolder:FindFirstChild(currentDragonIndex)
            if not dragonModel then
                warn("üö® DRAGON UNEQUIPPED! Re-equipping immediately...")
                EquipDragonByIndex(currentDragonIndex)
                task.wait(1)
                SitDragon(currentDragonIndex)
            end
        end)
    end
end)

--========================================================--
--        CHARACTER RESPAWN HANDLER (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡∏≤‡∏¢)          
--========================================================--

player.CharacterAdded:Connect(function(newChar)
    task.wait(2)
    
    pcall(function()
        if currentDragonIndex then
            print("üîÑ Character respawned! Mounting dragon...")
            EquipDragonByIndex(currentDragonIndex)
            task.wait(1)
            SitDragon(currentDragonIndex)
            task.wait(1)
            pcall(ensureMountedDragon)
        end
    end)
end)


--========================================================--
--           AUTO ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° Q ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏±‡∏á‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏ö‡∏¥‡∏ô (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç)
--========================================================--

local lastQPress = 0
local qPressCount = 0
local qPressResetTime = 0

local function enableFlyControlUseSpace()
    pcall(function()
        local data = safeWaitForChild(player, "Data", 5)
        if not data then return end

        local settings = safeWaitForChild(data, "Settings", 5)
        if not settings then return end

        local flyControlValue = settings:FindFirstChild("FlyControlUseSpace")
        if flyControlValue and flyControlValue.Value == true then
            flyControlValue.Value = false
            print("‚úÖ Changed to Q button")
        end
    end)
end

local function pressQ()
    local VIM = game:GetService("VirtualInputManager")
    VIM:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
    task.wait(0.05)
    VIM:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
    
    -- ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏î Q
    qPressCount = qPressCount + 1
    lastQPress = tick()
end

local function getDragonFlyingState()
    local success, result = pcall(function()
        local chars = workspace:FindFirstChild("Characters")
        if not chars then return false end
        
        local playerChar = chars:FindFirstChild(player.Name)
        if not playerChar then return false end
        
        local dragonsFolder = playerChar:FindFirstChild("Dragons")
        if not dragonsFolder then return false end

        for _, dragon in ipairs(dragonsFolder:GetChildren()) do
            if dragon:IsA("Model") then
                local dataFolder = dragon:FindFirstChild("Data")
                if dataFolder then
                    local flyingValue = dataFolder:FindFirstChild("Flying")
                    if flyingValue then
                        return flyingValue.Value == true
                    end
                end
            end
        end
        return false
    end)
    
    return success and result or false
end

-- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ Q spam bug ‡πÅ‡∏•‡∏∞ rejoin
task.spawn(function()
    while true do
        task.wait(5)
        
        -- ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï counter ‡∏ó‡∏∏‡∏Å 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        if tick() - qPressResetTime >= 10 then
            qPressCount = 0
            qPressResetTime = tick()
        end
        
        -- ‡∏ñ‡πâ‡∏≤‡∏Å‡∏î Q ‡πÄ‡∏Å‡∏¥‡∏ô 20 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÉ‡∏ô 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ = ‡∏ö‡∏±‡∏Ñ
        if qPressCount >= 20 then
            warn("üö® Q SPAM BUG DETECTED!")
            warn("üö® Pressed Q " .. qPressCount .. " times in 10 seconds")
            warn("üö® REJOINING SERVER...")
            
            rejoinServer()
            return
        end
    end
end)

task.spawn(function()
    task.wait(5)
    enableFlyControlUseSpace()
    
    while true do
        task.wait(2) 
        
        local isFlying = getDragonFlyingState()
        if not isFlying then
            print("‚ö†Ô∏è Dragon not flying ‚Üí Pressing Q once")
            pressQ()
            task.wait(1)
        end
    end
end)

--========================================================--
--                   GODMODE                              
--========================================================--

local function removeMobDamageRemote()
    task.spawn(function()
        pcall(function()
            local remotes = ReplicatedStorage:FindFirstChild("Remotes")
            if remotes then
                for i = 1, 15 do
                    for _, obj in ipairs(remotes:GetDescendants()) do
                        if obj.Name == "MobDamageRemote" then
                            obj:Destroy()
                        end
                    end
                    task.wait(1)
                end
            end
        end)
        
        while true do
            task.wait(5)
            pcall(function()
                local remotes = ReplicatedStorage:FindFirstChild("Remotes")
                if remotes then
                    for _, obj in ipairs(remotes:GetDescendants()) do
                        if obj.Name == "MobDamageRemote" then
                            obj:Destroy()
                        end
                    end
                end
            end)
        end
    end)
end

--========================================================--
--                   AUTO COLLECT                         
--========================================================--

local function AutoCollectDrops()
    while true do
        task.wait(CONFIG.AUTO_COLLECT_DELAY)
        pcall(function()
            local foodFolder = workspace.Interactions.Nodes:FindFirstChild("Food")
            if not foodFolder then return end
            for _, node in ipairs(foodFolder:GetChildren()) do
                local part = node:FindFirstChild("BillboardPart") or node:FindFirstChildWhichIsA("BasePart")
                if part then
                    for a = 1, 6 do
                        for b = 1, 6 do
                            pcall(function()
                                LargeDropsRemote:FireServer(part, a, b)
                            end)
                        end
                    end
                end
            end
        end)
    end
end

local function collectNearbyFoods()
    pcall(function()
        local char = player.Character
        if not char then return end
        local currentHrp = char:FindFirstChild("HumanoidRootPart")
        if not currentHrp then return end
        for _, obj in pairs(workspace.Camera:GetChildren()) do
            for _, name in ipairs(CollectableNames) do
                if obj.Name == name then
                    for _, part in pairs(obj:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CFrame = currentHrp.CFrame
                        end
                    end
                end
            end
        end
    end)
end

local function startAutoCollect()
    task.spawn(function()
        while task.wait(1) do
            collectNearbyFoods()
        end
    end)
end

--========================================================--
--                   HELPER FUNCTIONS                     
--========================================================--

local function getDragonRemote(dragonIndex)
    local success, remote = pcall(function()
        local chars = workspace:FindFirstChild("Characters")
        if not chars then return nil end
        local playerChar = chars:FindFirstChild(player.Name)
        if not playerChar then return nil end
        local dragonsFolder = playerChar:FindFirstChild("Dragons")
        if not dragonsFolder then return nil end
        local dragon = dragonsFolder:FindFirstChild(dragonIndex)
        if not dragon then return nil end
        local remotes = dragon:FindFirstChild("Remotes")
        if not remotes then return nil end
        return remotes:FindFirstChild("PlaySoundRemote")
    end)
    if success then
        return remote
    end
    return nil
end

local function isNodeDead(node)
    local success, isDead = pcall(function()
        if not node or not node.Parent then return true end
        local billboardPart = node:FindFirstChild("BillboardPart")
        if not billboardPart then return true end
        local deadValue = billboardPart:FindFirstChild("Dead")
        if not deadValue then return false end
        return deadValue.Value == true
    end)
    if not success then
        return true
    end
    return isDead
end

local function isNodeAlive(node)
    local success, result = pcall(function()
        if not node or not node.Parent then return false end
        local billboardPart = node:FindFirstChild("BillboardPart")
        if not billboardPart then return false end
        local deadValue = billboardPart:FindFirstChild("Dead")
        if not deadValue then return true end
        return deadValue.Value == false
    end)
    return success and result
end

local function getNodePart(node)
    local success, part = pcall(function()
        local billboardPart = node:FindFirstChild("BillboardPart")
        if billboardPart then return billboardPart end
        return node:FindFirstChildWhichIsA("BasePart", true)
    end)
    return success and part or nil
end

--========================================================--
--                   LOBBY QUESTS                         
--========================================================--

local function DoLobbyRings()
    print("Flying Rings...")
    while not checkAllQuests("Lobby").RidingRing do
        for i = 1, 99 do
            if checkAllQuests("Lobby").RidingRing then break end
            pcall(function()
                local char = player.Character or player.CharacterAdded:Wait()
                local hrp = char:WaitForChild("HumanoidRootPart")
                local ring = workspace.Interactions.RidingRings.Flying:FindFirstChild(tostring(i))
                if ring then
                    local pos = ring.CFrame.Position
                    hrp.CFrame = CFrame.new(pos - Vector3.new(0, 0, 15))
                    task.wait(0.05)
                    hrp.Velocity = (pos - hrp.Position).Unit * 60
                    task.wait(0.3)
                    hrp.Velocity = Vector3.new(0, 0, 0)
                    hrp.CFrame = ring.CFrame
                    task.wait(0.1)
                end
            end)
        end
        task.wait(0.5)
    end
    print("Riding Rings Complete!")
end

local function DoLobbyEggs()
    print("Farming Lobby Eggs...")
    while not checkAllQuests("Lobby").EggQuest do
        task.wait(1)
        pcall(function()
            if not player.Character then return end
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local eggNodesFolder = workspace.Interactions.Nodes.Eggs
            local activeNodes = eggNodesFolder.ActiveNodes
            local allNumbers = {}
            for _, child in pairs(eggNodesFolder:GetChildren()) do
                if child.Name ~= "ActiveNodes" and tonumber(child.Name) then
                    table.insert(allNumbers, child.Name)
                end
            end
            local nodes = activeNodes:GetChildren()
            if #nodes > 0 and #allNumbers > 0 then
                local firstNode = nodes[1]
                if firstNode:IsA("BasePart") then
                    hrp.CFrame = CFrame.new(firstNode.Position)
                elseif firstNode:IsA("Model") then
                    local primaryPart = firstNode.PrimaryPart or firstNode:FindFirstChildWhichIsA("BasePart")
                    if primaryPart then
                        hrp.CFrame = CFrame.new(primaryPart.Position)
                    end
                end
                task.wait(0.3)
                for _, eggNumber in pairs(allNumbers) do
                    pcall(function()
                        ReplicatedStorage.Remotes.SetCollectEggRemote:InvokeServer(eggNumber)
                        task.wait(0.05)
                        ReplicatedStorage.Remotes.CollectEggRemote:InvokeServer(eggNumber)
                        task.wait(0.05)
                    end)
                end
            end
        end)
    end
    print("Lobby Eggs Complete!")
end

--========================================================--
--                   STANDARD QUESTS                      
--========================================================--

local function doEggQuest(worldName)
    print("[STEP 1] Starting Egg Quest...")
    while true do
        local quests = checkAllQuests(worldName)
        if quests.EggQuest then
            print("[STEP 1] Egg Quest Complete!")
            break
        end
        task.wait(1)
        pcall(function()
            if not player.Character then return end
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local eggNodesFolder = workspace.Interactions.Nodes.Eggs
            local activeNodes = eggNodesFolder.ActiveNodes
            local allNumbers = {}
            for _, child in pairs(eggNodesFolder:GetChildren()) do
                if child.Name ~= "ActiveNodes" and tonumber(child.Name) then
                    table.insert(allNumbers, child.Name)
                end
            end
            local nodes = activeNodes:GetChildren()
            if #nodes > 0 and #allNumbers > 0 then
                local firstNode = nodes[1]
                if firstNode:IsA("BasePart") then
                    hrp.CFrame = CFrame.new(firstNode.Position)
                elseif firstNode:IsA("Model") then
                    local primaryPart = firstNode.PrimaryPart or firstNode:FindFirstChildWhichIsA("BasePart")
                    if primaryPart then
                        hrp.CFrame = CFrame.new(primaryPart.Position)
                    end
                end
                task.wait(0.3)
                for _, eggNumber in pairs(allNumbers) do
                    pcall(function()
                        ReplicatedStorage.Remotes.SetCollectEggRemote:InvokeServer(eggNumber)
                        task.wait(0.05)
                        ReplicatedStorage.Remotes.CollectEggRemote:InvokeServer(eggNumber)
                        task.wait(0.05)
                    end)
                end
            end
        end)
    end
end
local function isChestDead(chestNode)
    local success, isDead = pcall(function()
        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ chestNode ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
        if not chestNode or not chestNode.Parent then 
            return true 
        end
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ children (Model ‡∏Å‡∏•‡πà‡∏≠‡∏á)
        local children = chestNode:GetChildren()
        if #children == 0 then 
            return true 
        end
        
        -- ‡∏î‡∏∂‡∏á Model ‡∏Å‡∏•‡πà‡∏≠‡∏á (child ‡πÅ‡∏£‡∏Å)
        local chestModel = children[1]
        if not chestModel or not chestModel:IsA("Model") then 
            return true 
        end
        
        -- ‡∏´‡∏≤ HumanoidRootPart
        local hrp = chestModel:FindFirstChild("HumanoidRootPart")
        if not hrp then 
            return true 
        end
        
        -- ‡πÄ‡∏ä‡πá‡∏Ñ Dead Value
        local deadValue = hrp:FindFirstChild("Dead")
        if not deadValue then 
            return false -- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ Dead = ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢
        end
        
        return deadValue.Value == true
    end)
    
    -- ‡∏ñ‡πâ‡∏≤ error = ‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏≤‡∏¢ (‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á)
    if not success then
        warn("‚ö†Ô∏è Error checking chest:", chestNode.Name)
        return false
    end
    
    return isDead
end
local function getChestPosition(chestNode)
    local success, pos = pcall(function()
        local children = chestNode:GetChildren()
        if #children == 0 then return nil end
        
        local chestModel = children[1]
        if not chestModel or not chestModel:IsA("Model") then return nil end
        
        -- ‡∏´‡∏≤ HumanoidRootPart
        local hrp = chestModel:FindFirstChild("HumanoidRootPart")
        if hrp then
            return hrp.Position
        end
        
        -- ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡∏•‡∏≠‡∏á‡∏´‡∏≤ Part ‡∏≠‡∏∑‡πà‡∏ô
        local part = chestModel.PrimaryPart or chestModel:FindFirstChildWhichIsA("BasePart", true)
        if part then
            return part.Position
        end
        
        return nil
    end)
    
    if not success then
        warn("‚ö†Ô∏è Error getting position:", chestNode.Name)
        return nil
    end
    
    return pos
end
local function findNearestAliveChest()
    local treasureFolder = workspace.Interactions.Nodes.Treasure
    if not treasureFolder then 
        warn("‚ö†Ô∏è Treasure folder not found")
        return nil 
    end
    
    local nearestChest, shortestDistance = nil, math.huge
    local aliveChestCount = 0
    
    for _, chestNode in pairs(treasureFolder:GetChildren()) do
        local isDead = isChestDead(chestNode)
        
        -- ‚úÖ ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà Dead = false
        if not isDead then
            aliveChestCount = aliveChestCount + 1
            
            local chestPos = getChestPosition(chestNode)
            if chestPos then
                local char = player.Character
                if not char then return nil end
                
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if not hrp then return nil end
                
                local distance = (chestPos - hrp.Position).Magnitude
                
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestChest = {
                        node = chestNode,
                        position = chestPos,
                        distance = distance,
                        name = chestNode.Name
                    }
                end
            end
        end
    end
    
    print("üìä Found " .. aliveChestCount .. " alive chests")
    return nearestChest
end
local function openAllChestsAndNodes()
    local startTime = tick()
    local nodesFolder = workspace:FindFirstChild("Interactions") 
                        and workspace.Interactions:FindFirstChild("Nodes")
    
    if not nodesFolder then
        warn("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå Nodes ‡πÉ‡∏ô workspace.Interactions")
        return
    end
    
    print("üîì ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏µ‡∏ö‡πÅ‡∏•‡∏∞ Nodes ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î...")
    
    while tick() - startTime < 5 do
        local openedCount = 0
        
        -- ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏ó‡∏∏‡∏Å Node (Treasure, Ores, Plants ‡∏Ø‡∏•‡∏Ø)
        for _, category in ipairs(nodesFolder:GetChildren()) do
            if category:IsA("Folder") then
                for _, node in ipairs(category:GetChildren()) do
                    pcall(function()
                        -- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ HumanoidRootPart ‡∏´‡∏£‡∏∑‡∏≠ PrimaryPart
                        local rootPart = node:FindFirstChild("HumanoidRootPart") 
                                      or node:FindFirstChild("PrimaryPart")
                                      or node:FindFirstChildWhichIsA("BasePart")
                        
                        if rootPart then
                            -- ‡πÄ‡∏ä‡πá‡∏Ñ Attribute "Dead"
                            local isDead = rootPart:GetAttribute("Dead")
                            
                            if isDead ~= nil and isDead == false then
                                -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô true
                                rootPart:SetAttribute("Dead", true)
                                openedCount = openedCount + 1
                                print(("‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î: %s (%s)"):format(node.Name, category.Name))
                            end
                        end
                    end)
                end
            end
        end
        
        if openedCount > 0 then
            print(("üì¶ ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß %d ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£"):format(openedCount))
        end
        
        task.wait(0.5) -- ‡∏£‡∏≠ 0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ä‡πá‡∏Ñ‡∏£‡∏≠‡∏ö‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
    end
    
    print("‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏¥‡∏î‡∏´‡∏µ‡∏ö‡πÅ‡∏•‡∏∞ Nodes!")
end
local function doTreasureQuest(worldName, locations)
    print("[STEP 2] Starting Treasure Quest...")
    
    local lastPositionChangeTime = 0
    local currentLocationIndex = 1

    while true do
        local quests = checkAllQuests(worldName)
        if quests and quests.TreasureChest then
            print("[STEP 2] Treasure Quest Complete!")
            break
        end

        task.wait(1)

        pcall(function()
            local char = player.Character
            if not char then return end

            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            -- ‡∏´‡∏≤‡∏Å‡∏•‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà Dead = false
            local nearestChest = findNearestAliveChest()

            if nearestChest and nearestChest.position then
                print("‚úÖ Found alive chest: " .. nearestChest.name)
                print("üìç Distance: " .. math.floor(nearestChest.distance) .. " studs")
                
                -- ‡∏ß‡∏≤‡∏£‡πå‡∏õ‡πÑ‡∏õ‡∏´‡∏≤‡∏Å‡∏•‡πà‡∏≠‡∏á
                hrp.CFrame = CFrame.new(nearestChest.position + Vector3.new(0, 5, 0))
                task.wait(1)

                -- ‚úÖ ‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πà‡∏≠‡∏á - ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Dead = true
                print("üîì Opening chest...")
                local openSuccess = pcall(function()
                    local children = nearestChest.node:GetChildren()
                    if #children == 0 then 
                        warn("‚ö†Ô∏è Chest has no children")
                        return 
                    end
                    
                    local chestModel = children[1]
                    if not chestModel then 
                        warn("‚ö†Ô∏è Chest model not found")
                        return 
                    end
                    
                    local hrpPart = chestModel:FindFirstChild("HumanoidRootPart")
                    if not hrpPart then 
                        warn("‚ö†Ô∏è HumanoidRootPart not found in chest")
                        return 
                    end
                    
                    local deadValue = hrpPart:FindFirstChild("Dead")
                    if not deadValue then 
                        warn("‚ö†Ô∏è Dead value not found")
                        return 
                    end
                    
                    -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡πà‡∏≤
                    deadValue.Value = true
                    print("‚úÖ Set Dead = true for: " .. nearestChest.name)
                end)
                
                if not openSuccess then
                    warn("‚ùå Failed to open chest!")
                end
                
                task.wait(2)
                print("üíé Waiting for loot (7 seconds)...")
                task.wait(7)

            else
                print("‚ö†Ô∏è No alive chest found, moving to patrol point...")
                
                if tick() - lastPositionChangeTime >= 5 then
                    currentLocationIndex = currentLocationIndex + 1
                    if currentLocationIndex > #locations then
                        currentLocationIndex = 1
                    end

                    local newLocation = locations[currentLocationIndex]
                    print("üìç Moving to patrol point " .. currentLocationIndex)

                    hrp.CFrame = CFrame.new(newLocation)
                    lastPositionChangeTime = tick()
                    task.wait(3)
                end
            end
        end)
    end
end


local function findNearestMob()
    local mobFolder = workspace:WaitForChild("MobFolder")
    local nearestMob, shortestDistance = nil, math.huge
    for _, mobContainer in pairs(mobFolder:GetChildren()) do
        local mob = mobContainer:GetChildren()[1]
        if mob then
            local isDead = false
            pcall(function()
                if mob:FindFirstChild("Dead") and mob.Dead.Value == true then
                    isDead = true
                end
            end)
            if not isDead then
                local mobPos = nil
                if mob:IsA("Model") then
                    local part = mob.PrimaryPart or mob:FindFirstChildWhichIsA("BasePart", true)
                    if part then mobPos = part.Position end
                elseif mob:IsA("BasePart") then
                    mobPos = mob.Position
                end
                if mobPos then
                    local char = player.Character
                    if not char then return nil end
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if not hrp then return nil end
                    local dist = (mobPos - hrp.Position).Magnitude
                    if dist < shortestDistance then
                        shortestDistance = dist
                        nearestMob = {container = mobContainer, mob = mob, position = mobPos}
                    end
                end
            end
        end
    end
    return nearestMob
end

local function isMobDead(mobContainer, mob)
    if #mobContainer:GetChildren() == 0 then return true end
    local success, dead = pcall(function()
        return mob:FindFirstChild("Dead") and mob.Dead.Value == true
    end)
    if success and dead then return true end
    if not mob.Parent then return true end
    return false
end

local function doKillMobsQuest(worldName)
    print("[STEP 3] Starting Kill Mobs Quest...")
    while true do
        local quests = checkAllQuests(worldName)
        if quests.KillMobs then
            print("[STEP 3] Kill Mobs Quest Complete!")
            break
        end
        task.wait(0.1)
        pcall(function()
            if not player.Character then return end
            local hrp = player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local target = findNearestMob()
            if target then
                hrp.CFrame = CFrame.new(target.position + Vector3.new(0, 5, 0))
                task.wait(0.1)
                local attackLoop = 0
                while not isMobDead(target.container, target.mob) and attackLoop < 200 do
                    pcall(function()
                        local dragonFolder = player.Character:WaitForChild("Dragons")
                        local dragon = dragonFolder:FindFirstChild("2") or dragonFolder:FindFirstChild("1")
                        if dragon then
                            dragon.Remotes.PlaySoundRemote:FireServer("Breath", "Mobs", target.mob)
                        end
                    end)
                    attackLoop = attackLoop + 1
                    task.wait(0.05)
                end
            else
                task.wait(1)
            end
        end)
    end
end

local MONSTER_RANGE = 200
local isBossFarming = false
local currentBossName = nil

local function collectBossLoot()
    task.wait(5)
    pcall(function()
        local args = {2}
        ReplicatedStorage.Remotes.GetBossLootRemote:InvokeServer(unpack(args))
    end)
end

local function isBossDead(bossName)
    if not bossName then return false end
    local success, isDead = pcall(function()
        local bossInstances = workspace.Interactions.Boss.BossInstances
        local bossInstance = bossInstances:FindFirstChild(bossName)
        if bossInstance then
            local deadValue = bossInstance:FindFirstChild("Dead")
            if deadValue then
                return deadValue.Value == true
            end
        end
        return false
    end)
    return success and isDead
end

local function findNearestBoss()
    local activeBosses = workspace:FindFirstChild("ActiveBossModels")
    if not activeBosses then return nil end
    local nearestBoss, shortestDistance = nil, math.huge
    for _, boss in pairs(activeBosses:GetChildren()) do
        local hrp = boss:FindFirstChild("HumanoidRootPart")
        if hrp then
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local dist = (hrp.Position - char.HumanoidRootPart.Position).Magnitude
                if dist < shortestDistance then
                    shortestDistance = dist
                    nearestBoss = boss
                end
            end
        end
    end
    return nearestBoss
end

local function findMonstersNearBoss(bossPosition)
    local mobFolder = workspace:FindFirstChild("MobFolder")
    if not mobFolder then return {} end
    local nearbyMobs = {}
    for _, mobContainer in pairs(mobFolder:GetChildren()) do
        if not isMobDead(mobContainer, mobContainer:GetChildren()[1]) then
            local mob = mobContainer:GetChildren()[1]
            if mob then
                local mobPos = nil
                if mob:IsA("Model") then
                    local part = mob.PrimaryPart or mob:FindFirstChildWhichIsA("BasePart", true)
                    if part then mobPos = part.Position end
                elseif mob:IsA("BasePart") then
                    mobPos = mob.Position
                end
                if mobPos then
                    local distance = (mobPos - bossPosition).Magnitude
                    if distance <= MONSTER_RANGE then
                        table.insert(nearbyMobs, {container = mobContainer, mob = mob, position = mobPos})
                    end
                end
            end
        end
    end
    return nearbyMobs
end

local function killMonster(mobContainer, mob)
    local char = player.Character
    if not char then return end
    local charHrp = char:FindFirstChild("HumanoidRootPart")
    if not charHrp then return end
    local mobPos = nil
    if mob:IsA("Model") then
        local part = mob.PrimaryPart or mob:FindFirstChildWhichIsA("BasePart", true)
        if part then mobPos = part.Position end
    elseif mob:IsA("BasePart") then
        mobPos = mob.Position
    end
    if not mobPos then return end
    charHrp.CFrame = CFrame.new(mobPos + Vector3.new(0, 5, 0))
    task.wait(0.1)
    local attackLoop = 0
    while not isMobDead(mobContainer, mob) and attackLoop < 200 do
        pcall(function()
            local dragonsFolder = char:FindFirstChild("Dragons")
            if not dragonsFolder then return end
            local dragon = dragonsFolder:FindFirstChild("1") or dragonsFolder:FindFirstChild("2")
            if not dragon then return end
            local remote = dragon:FindFirstChild("Remotes")
            if not remote then return end
            local playSound = remote:FindFirstChild("PlaySoundRemote")
            if not playSound then return end
            playSound:FireServer("Breath", "Mobs", mob)
        end)
        attackLoop = attackLoop + 1
        task.wait(0.05)
    end
end

local function attackBossLoop()
    while isBossFarming do
        task.wait(0.1)
        pcall(function()
            local boss = findNearestBoss()
            if not boss then
                task.wait(2)
                return
            end
            currentBossName = boss.Name
            if isBossDead(currentBossName) then
                collectBossLoot()
                isBossFarming = false
                return
            end
            local bossHrp = boss:FindFirstChild("HumanoidRootPart")
            if not bossHrp then return end
            local nearbyMobs = findMonstersNearBoss(bossHrp.Position)
            if #nearbyMobs > 0 then
                for _, mobData in ipairs(nearbyMobs) do
                    if not isMobDead(mobData.container, mobData.mob) then
                        killMonster(mobData.container, mobData.mob)
                    end
                    task.wait(0.1)
                end
                task.wait(0.5)
            else
                local char = player.Character
                if not char then return end
                local charHrp = char:FindFirstChild("HumanoidRootPart")
                if not charHrp then return end
                charHrp.CFrame = bossHrp.CFrame * CFrame.new(0, 4, 0)
                local dragonsFolder = char:FindFirstChild("Dragons")
                if not dragonsFolder then return end
                local dragon = dragonsFolder:FindFirstChild("1") or dragonsFolder:FindFirstChild("2")
                if not dragon then return end
                local remote = dragon:FindFirstChild("Remotes")
                if not remote then return end
                local playSound = remote:FindFirstChild("PlaySoundRemote")
                if not playSound then return end
                for i = 1, 3 do
                    pcall(function()
                        playSound:FireServer("Breath", "Bosses", bossHrp)
                    end)
                end
                task.wait(0.05)
            end
        end)
    end
end

local function doBossQuest(worldName)
    print("[STEP 4] Starting Boss Quest...")
    pcall(function()
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            local startZone = workspace.Interactions.Boss.StartZone.Part
            char.HumanoidRootPart.CFrame = startZone.CFrame
        end
    end)
    task.wait(2)
    pcall(function()
        local args = {"NoOne"}
        ReplicatedStorage.Remotes.CreateBossQueueRemote:InvokeServer(unpack(args))
    end)
    task.wait(2)
    pcall(function()
        ReplicatedStorage.Remotes.StartBossQueueRemote:InvokeServer()
    end)
    task.wait(2)
    pcall(function()
        local args = {
            "ToBossInstance",
            {
                FightId = player.UserId .. "-SitingoRomam",
                Spawn = true
            }
        }
        ReplicatedStorage.Remotes.GetTeleportRemote:InvokeServer(unpack(args))
    end)
    task.wait(3)
    isBossFarming = true
    attackBossLoop()
    print("[STEP 4] Boss Quest Complete!")
end

--========================================================--
--         HARVEST QUEST (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç - Skip ‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÅ‡∏ï‡∏Å)
--========================================================--

local skippedNodes = {} -- ‡πÄ‡∏Å‡πá‡∏ö‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡πÑ‡∏°‡πà‡πÅ‡∏ï‡∏Å

local function AttackNode(targetPart, node, dragonIndex)
    local isFlying = getDragonFlyingState()
    if not isFlying then
        print("Dragon not flying! Pressing Q...")
        pressQ()
        task.wait(2)
        isFlying = getDragonFlyingState()
        if not isFlying then
            warn("Dragon still not flying! Skipping node...")
            return false
        end
    end
    
    local attackCount = 0
    while true do
        if isNodeDead(node) then
            print("Tree destroyed!")
            return true -- ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        end
        
        pcall(function()
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.CFrame = targetPart.CFrame + CONFIG.TELEPORT_OFFSET
            end
        end)
        
        local remote = getDragonRemote(dragonIndex)
        if not remote then
            warn("No dragon remote!")
            return false
        end
        
        for i = 1, 3 do
            pcall(function()
                remote:FireServer("Breath", "Destructibles", targetPart)
            end)
        end
        
        attackCount = attackCount + 1

        if attackCount >= 100 then
            warn("Node attack timeout (100 hits) - Skipping to next tree")
            table.insert(skippedNodes, node) -- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ blacklist
            return false -- ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        end
        
        task.wait(CONFIG.ATTACK_DELAY)
    end
end

--========================================================--
--         HARVEST QUEST (‡πÉ‡∏ä‡πâ Tween ‡πÅ‡∏ó‡∏ô‡∏ß‡∏≤‡∏õ)
--========================================================--

local TweenService = game:GetService("TweenService")
local skippedNodes = {}

local function TweenToPosition(targetCFrame, speed)
    speed = 300 -- ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß studs/‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
    
    local char = player.Character
    if not char then return false end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local distance = (hrp.Position - targetCFrame.Position).Magnitude
    local duration = distance / speed
    
    local tween = TweenService:Create(
        hrp,
        TweenInfo.new(duration, Enum.EasingStyle.Linear),
        {CFrame = targetCFrame}
    )
    
    tween:Play()
    tween.Completed:Wait()
    
    return true
end

local function AttackNode(targetPart, node, dragonIndex)
    local isFlying = getDragonFlyingState()
    if not isFlying then
        print("Dragon not flying! Pressing Q...")
        pressQ()
        task.wait(2)
        isFlying = getDragonFlyingState()
        if not isFlying then
            warn("Dragon still not flying! Skipping node...")
            return false
        end
    end
    
    -- Tween ‡πÑ‡∏õ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å
    print("Flying to tree...")
    local targetCFrame = targetPart.CFrame + CONFIG.TELEPORT_OFFSET
    TweenToPosition(targetCFrame, 150)
    
    task.wait(0.5)
    
    local attackCount = 0
    local lastTweenTime = tick()
    
    while true do
        if isNodeDead(node) then
            print("Tree destroyed!")
            return true
        end
        
        -- Tween ‡∏ó‡∏∏‡∏Å 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ö‡πà‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)
        if tick() - lastTweenTime >= 3 then
            pcall(function()
                local char = player.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    TweenToPosition(targetPart.CFrame + CONFIG.TELEPORT_OFFSET, 150)
                end
            end)
            lastTweenTime = tick()
        end
        
        local remote = getDragonRemote(dragonIndex)
        if not remote then
            warn("No dragon remote!")
            return false
        end
        
        for i = 1, 3 do
            pcall(function()
                remote:FireServer("Breath", "Destructibles", targetPart)
            end)
        end
        
        attackCount = attackCount + 1

        if attackCount >= 100 then
            warn("Node attack timeout (100 hits) - Skipping to next tree")
            table.insert(skippedNodes, node)
            return false
        end
        
        task.wait(CONFIG.ATTACK_DELAY)
    end
end

--========================================================--
--         HARVEST QUEST (Tween ‡∏°‡∏±‡∏á‡∏Å‡∏£)
--========================================================--

local TweenService = game:GetService("TweenService")
local skippedNodes = {}

local function TweenDragonToPosition(targetCFrame, speed, dragonIndex)
    speed = 300
    
    pcall(function()
        local chars = workspace:FindFirstChild("Characters")
        if not chars then return end
        
        local playerChar = chars:FindFirstChild(player.Name)
        if not playerChar then return end
        
        local dragonsFolder = playerChar:FindFirstChild("Dragons")
        if not dragonsFolder then return end
        
        local dragonModel = dragonsFolder:FindFirstChild(dragonIndex)
        if not dragonModel then return end
        
        -- ‡∏´‡∏≤ PrimaryPart ‡∏Ç‡∏≠‡∏á‡∏°‡∏±‡∏á‡∏Å‡∏£
        local dragonPart = dragonModel.PrimaryPart or dragonModel:FindFirstChildWhichIsA("BasePart")
        if not dragonPart then return end
        
        local distance = (dragonPart.Position - targetCFrame.Position).Magnitude
        local duration = distance / speed
        
        print("Tweening dragon... " .. math.floor(distance) .. " studs")
        
        -- Tween ‡∏°‡∏±‡∏á‡∏Å‡∏£
        local tween = TweenService:Create(
            dragonPart,
            TweenInfo.new(duration, Enum.EasingStyle.Linear),
            {CFrame = targetCFrame}
        )
        
        tween:Play()
        tween.Completed:Wait()
    end)
end

local function AttackNode(targetPart, node, dragonIndex)
    local isFlying = getDragonFlyingState()
    if not isFlying then
        print("Dragon not flying! Pressing Q...")
        pressQ()
        task.wait(2)
        isFlying = getDragonFlyingState()
        if not isFlying then
            warn("Dragon still not flying! Skipping node...")
            return false
        end
    end
    
    -- Tween ‡∏°‡∏±‡∏á‡∏Å‡∏£‡πÑ‡∏õ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
    print("Flying to tree...")
    local targetCFrame = targetPart.CFrame + CONFIG.TELEPORT_OFFSET
    TweenDragonToPosition(targetCFrame, 150, dragonIndex)
    
    task.wait(0.5)
    
    local attackCount = 0
    local lastTweenTime = tick()
    
    while true do
        if isNodeDead(node) then
            print("Tree destroyed!")
            return true
        end
        
        -- Tween ‡∏Å‡∏•‡∏±‡∏ö‡∏ó‡∏∏‡∏Å 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        if tick() - lastTweenTime >= 3 then
            TweenDragonToPosition(targetPart.CFrame + CONFIG.TELEPORT_OFFSET, 150, dragonIndex)
            lastTweenTime = tick()
        end
        
        local remote = getDragonRemote(dragonIndex)
        if not remote then
            warn("No dragon remote!")
            return false
        end
        
        for i = 1, 3 do
            pcall(function()
                remote:FireServer("Breath", "Destructibles", targetPart)
            end)
        end
        
        attackCount = attackCount + 1

        if attackCount >= 100 then
            warn("Node attack timeout (100 hits) - Skipping to next tree")
            table.insert(skippedNodes, node)
            return false
        end
        
        task.wait(CONFIG.ATTACK_DELAY)
    end
end

local function doHarvestQuest(worldName, patrol, dragonIndex)
    print("[STEP 6] Starting Harvest Quest...")
    
    skippedNodes = {}
    
    while true do
        local quests = checkAllQuests(worldName)
        if quests.Harvest then
            print("[STEP 6] Harvest Quest Complete!")
            break
        end
        
        task.wait(0.5)
        
        pcall(function()
            local char = player.Character
            if not char then return end
            
            local currentHrp = char:FindFirstChild("HumanoidRootPart")
            if not currentHrp then return end

            if not IsPlayerSeatedOnDragon(dragonIndex) then
                warn("Not seated on dragon! Re-mounting...")
                EquipDragonByIndex(dragonIndex)
                task.wait(1)
                SitDragon(dragonIndex)
                task.wait(2)
                return
            end

            local isFlying = getDragonFlyingState()
            if not isFlying then
                print("Dragon not flying! Pressing Q...")
                pressQ()
                task.wait(2)
                return
            end
            
            local foodFolder = workspace.Interactions.Nodes:FindFirstChild("Food")
            if not foodFolder then return end

            local aliveNodes = {}
            for _, node in ipairs(foodFolder:GetChildren()) do
                if isNodeAlive(node) then
                    local isSkipped = false
                    for _, skippedNode in ipairs(skippedNodes) do
                        if skippedNode == node then
                            isSkipped = true
                            break
                        end
                    end
                    
                    if not isSkipped then
                        table.insert(aliveNodes, node)
                    end
                end
            end
            
            if #aliveNodes == 0 then
                print("No available trees (all skipped or waiting respawn)...")
                
                if #skippedNodes > 0 then
                    print("Resetting blacklist and trying again...")
                    skippedNodes = {}
                end
                
                task.wait(5)
            else
                print("Found " .. #aliveNodes .. " available trees")
                
                local nearestNode = nil
                local shortestDistance = math.huge
                
                for _, node in ipairs(aliveNodes) do
                    local part = getNodePart(node)
                    if part then
                        local distance = (part.Position - currentHrp.Position).Magnitude
                        if distance < shortestDistance then
                            shortestDistance = distance
                            nearestNode = node
                        end
                    end
                end
                
                if nearestNode then
                    local part = getNodePart(nearestNode)
                    if part then
                        print("Flying to nearest tree (" .. math.floor(shortestDistance) .. " studs)")
                        local success = AttackNode(part, nearestNode, dragonIndex)
                        
                        if success then
                            print("Tree destroyed successfully!")
                        else
                            print("Failed to destroy tree, moving to next one...")
                        end
                        
                        task.wait(0.5)
                    end
                end
            end
        end)
    end
end

--========================================================--
--                  MAIN FARM FUNCTION                    
--========================================================--

local function runAllQuests(worldName, dragonIndex)
    print("Starting " .. worldName .. " Quest Sequence...")
    
    if worldName == "Lobby" then
        local quests = checkAllQuests("Lobby")
        if not quests.RidingRing then
            DoLobbyRings()
            task.wait(2)
        end
        if not quests.EggQuest then
            DoLobbyEggs()
        end
    else
        local pos = WORLD_POSITIONS[worldName]
        if not pos then
            warn("No data for " .. worldName)
            return false
        end
        
        doEggQuest(worldName)
        task.wait(2)
        
        doTreasureQuest(worldName, pos.Treasure)
        task.wait(2)
        
        doKillMobsQuest(worldName)
        task.wait(2)
        
        if worldName ~= "Grassland" then
            local quests = checkAllQuests(worldName)
            if not quests.KillBoss then
                doBossQuest(worldName)
            end
            task.wait(2)
            
            quests = checkAllQuests(worldName)
            if not quests.SpendTime then
                print("[STEP 5] Waiting for SpendTime Quest...")
                while true do
                    task.wait(10)
                    quests = checkAllQuests(worldName)
                    if quests.SpendTime then
                        print("[STEP 5] SpendTime Quest Complete!")
                        break
                    end
                end
            end
            task.wait(2)
        end
        
        doHarvestQuest(worldName, pos.Patrol, dragonIndex)
    end
    
    print("ALL " .. worldName:upper() .. " QUESTS COMPLETE!")
    return true
end

--========================================================--
--              UNDERCITY CHECK FUNCTION                  
--========================================================--

local function checkUndercityStatus()
    local success, status = pcall(function()
        return player.Data.Worlds.Undercity.Value
    end)
    
    if success then
        return status
    end
    return false
end


--========================================================--
--         WORLD DETECTION & HELPER FUNCTIONS            
--========================================================--

local function getCurrentWorld()
    local currentPlaceId = game.PlaceId
    for _, worldData in ipairs(WORLDS) do
        if worldData.placeId == currentPlaceId then
            return worldData
        end
    end
    return nil
end

local function GetHighestUnlockedWorld()
    print("Checking highest unlocked world...")
    
    local undercityUnlocked = checkUndercityStatus()
    
    if not undercityUnlocked then
        print("‚ö†Ô∏è Undercity LOCKED - Must farm Lobby!")
        return WORLDS[1]
    end
    
    print("‚úÖ Undercity UNLOCKED - Checking other worlds...")
    
    local highestWorld, highestOrder = nil, 0
    for _, world in ipairs(WORLDS) do
        local success, isUnlocked = pcall(function()
            if not player.Data then return false end
            local worldsFolder = player.Data:FindFirstChild("Worlds")
            if not worldsFolder then return false end
            local worldValue = worldsFolder:FindFirstChild(world.name)
            if not worldValue then return false end
            return worldValue.Value == true
        end)
        if success and isUnlocked then
            print("  OK " .. world.name .. " (Order: " .. tostring(world.order) .. ") - UNLOCKED")
            local worldOrder = tonumber(world.order) or 0
            if worldOrder > highestOrder then
                highestOrder = worldOrder
                highestWorld = world
            end
        else
            print("  LOCKED " .. world.name .. " (Order: " .. tostring(world.order) .. ")")
        end
    end
    if highestWorld then
        print("Highest Unlocked: " .. highestWorld.name .. " (Order: " .. tostring(highestWorld.order) .. ")")
    else
        print("WARNING: No worlds unlocked! Starting from Lobby")
        highestWorld = WORLDS[1]
    end
    return highestWorld
end

--========================================================--
--                    INITIALIZATION                      
--========================================================--

removeMobDamageRemote()
task.spawn(AutoCollectDrops)
startAutoCollect()

--========================================================--
--                  DAILY LOGIN CLAIM                     
--========================================================--

local function AutoClaimDailyLogin()
    task.spawn(function()
        print("üéÅ Starting Auto Daily Login Claim...")
        
        while true do
            task.wait(120)
            
            pcall(function()
                local claimRemote = safeWaitForChild(player.Data, "DailyLogin", 5)
                if not claimRemote then return end
                
                claimRemote = safeWaitForChild(claimRemote, "ClaimRemote", 5)
                if not claimRemote then return end
                
                for day = 1, 14 do
                    pcall(function()
                        local args = {day}
                        claimRemote:InvokeServer(unpack(args))
                        print("üéÅ Claimed Daily Login Day " .. day)
                    end)
                    task.wait(0.5)
                end
                
                print("‚úÖ Daily Login Claim Complete (1-14)")
            end)
        end
    end)
end

AutoClaimDailyLogin()

print("Initializing in 2 seconds...")
task.wait(2)

local dragonIndex, level = GetBestDragonIndex()
if not dragonIndex then
    warn("Dragon not found:", CONFIG.DRAGON_NAME)
    return
end

currentDragonIndex = dragonIndex
print("Using dragon:", CONFIG.DRAGON_NAME, "| Index:", dragonIndex, "| Level:", level)

task.spawn(function()
    task.wait(1)
    if not IsPlayerSeatedOnDragon(dragonIndex) then
        EquipDragonByIndex(dragonIndex)
        task.wait(1)
        SitDragon(dragonIndex)
    end
end)

task.wait(3)


-------------------------------------------------------------------------
-- AUTO REJOIN IF STUCK ON SAME QUEST (200 SECONDS)
-------------------------------------------------------------------------
local lastQuestState = nil
local lastWorldName = nil
local lastStateChangeTime = tick()

local function getCurrentQuestState(worldName)
    local quests = checkAllQuests(worldName)
    local state = ""
    
    if worldName == "Lobby" then
        state = tostring(quests.RidingRing) .. "_" .. tostring(quests.EggQuest)
    elseif worldName == "Grassland" then
        state = tostring(quests.EggQuest) .. "_" .. tostring(quests.TreasureChest) .. "_" .. 
                tostring(quests.KillMobs) .. "_" .. tostring(quests.Harvest)
    else
        state = tostring(quests.EggQuest) .. "_" .. tostring(quests.TreasureChest) .. "_" .. 
                tostring(quests.KillMobs) .. "_" .. tostring(quests.KillBoss) .. "_" .. 
                tostring(quests.Harvest)
    end
    
    return state
end

local function rejoinServer()
    print("üîÑ STUCK DETECTED! REJOINING SERVER...")
    pcall(function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
    end)
    task.wait(5)
    pcall(function()
        game:GetService("TeleportService"):Teleport(game.PlaceId, player)
    end)
end

task.spawn(function()
    task.wait(60)
    print("[AUTO REJOIN] System Started - Will rejoin if stuck for 200 seconds")
    
    while true do
        task.wait(10)
        
        pcall(function()
            local currentWorld = getCurrentWorld()
            if not currentWorld then return end
            
            local currentWorldName = currentWorld.name
            local currentQuestState = getCurrentQuestState(currentWorldName)
            
            if currentQuestState ~= lastQuestState or currentWorldName ~= lastWorldName then
                lastQuestState = currentQuestState
                lastWorldName = currentWorldName
                lastStateChangeTime = tick()
                print("[AUTO REJOIN] Quest changed - Timer reset")
            else
                local elapsedTime = tick() - lastStateChangeTime
                local secondsLeft = 200 - elapsedTime
                
                if elapsedTime >= 200 then
                    warn("üö® [AUTO REJOIN] STUCK FOR 200+ SECONDS!")
                    warn("üö® World: " .. currentWorldName)
                    warn("üö® Quest: " .. currentQuestState)
                    warn("üö® REJOINING NOW...")
                    
                    rejoinServer()
                    return
                elseif math.floor(secondsLeft) % 30 == 0 and secondsLeft < 200 then
                    print("[AUTO REJOIN] Same quest for " .. math.floor(elapsedTime) .. "s (Rejoin in " .. math.floor(secondsLeft) .. "s)")
                end
            end
        end)
    end
end)

print("‚úÖ Auto Rejoin System Loaded (200s timeout)")

-------------------------------------------------------------------------
-- UI 
-------------------------------------------------------------------------
local function showFinishUI()
    if game:GetService("CoreGui"):FindFirstChild("FarmFinishNotify") then return end
    if game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("FarmFinishNotify") then return end

    local gui = Instance.new("ScreenGui")
    gui.Name = "FarmFinishNotify"
    gui.DisplayOrder = 99999
    gui.IgnoreGuiInset = true

    local success, _ = pcall(function()
        gui.Parent = game:GetService("CoreGui")
    end)
    if not success then
        gui.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
    end

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0.8, 0, 0.8, 0)
    frame.Position = UDim2.new(0.5, 0, 0.5, 0)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    frame.BorderSizePixel = 0
    frame.Parent = gui

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 20)
    corner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(0, 255, 127)
    stroke.Thickness = 5
    stroke.Parent = frame

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = "ALL WORLD\nUNLOCK"
    label.TextColor3 = Color3.fromRGB(0, 255, 127)
    label.TextScaled = true
    label.Font = Enum.Font.FredokaOne
    label.Parent = frame

    local pad = Instance.new("UIPadding")
    pad.PaddingTop = UDim.new(0.1, 0)
    pad.PaddingBottom = UDim.new(0.1, 0)
    pad.PaddingLeft = UDim.new(0.05, 0)
    pad.PaddingRight = UDim.new(0.05, 0)
    pad.Parent = label

    local closeBtn = Instance.new("TextButton")
    closeBtn.Size = UDim2.new(0, 60, 0, 60)
    closeBtn.Position = UDim2.new(1, -70, 0, 10)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
    closeBtn.Text = "X"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.TextSize = 30
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.Parent = frame

    local btnCorner = Instance.new("UICorner")
    btnCorner.CornerRadius = UDim.new(0, 10)
    btnCorner.Parent = closeBtn

    closeBtn.MouseButton1Click:Connect(function()
        gui:Destroy()
    end)
end

-------------------------------------------------------------------------
--  Main Loop 
-------------------------------------------------------------------------
while true do

    local tutorStatus = getTutorialStatus() 
    
    if tutorStatus ~= "Complete" then
        print("‚ö†Ô∏è Tutorial not complete! Status: " .. tostring(tutorStatus))
        print("üîÑ Running tutorial script...")
        
        pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/ZeroVector101010101/bypassasd54818dadv/refs/heads/main/dddddd", true))()
        end)
        
        print("‚è∏Ô∏è Waiting 15 seconds for tutorial completion...")
        task.wait(15)
    else
        local isShinrinUnlocked = false
        pcall(function()
            if game:GetService("Players").LocalPlayer.Data.Worlds.Shinrin.Value == true then
                isShinrinUnlocked = true
            end
        end)

        if isShinrinUnlocked then
            print("üéâ ALL WORLD UNLOCK DETECTED!")
            showFinishUI()
            break
        end

        print("‚úÖ Tutorial Complete - Starting farm cycle")
        print("\n==================================================")
        print("Starting New Cycle...")
        print("==================================================\n")
        
        local success, errorMsg = pcall(function()
            local currentWorld = getCurrentWorld()
            
            if not currentWorld then
                warn("Cannot detect current world!")
                TPWorld(WORLDS[1].placeId, "Lobby")
                task.wait(15)
                return
            end
            
            local currentOrder = tonumber(currentWorld.order) or 1
            print("Current World: " .. currentWorld.name .. " (Order: " .. tostring(currentOrder) .. ")")
            
            local highestWorld = GetHighestUnlockedWorld()
            
            if not highestWorld then
                warn("No worlds unlocked!")
                task.wait(10)
                return
            end
            
            local highestOrder = tonumber(highestWorld.order) or 1
            print("Highest Unlocked: " .. highestWorld.name .. " (Order: " .. tostring(highestOrder) .. ")")
            
            if currentWorld.name ~= highestWorld.name then
                print("Not at highest world!")
                print("Teleporting to: " .. highestWorld.name)
                TPWorld(highestWorld.placeId, highestWorld.name)
                task.wait(15)
                return
            end
            
            print("At highest world: " .. currentWorld.name)
            print("\nChecking quest status...")
            printQuestStatus(currentWorld.name)
            
            local questsComplete = allQuestsComplete(currentWorld.name)
            
            if not questsComplete then
                print("\nQuests incomplete in " .. currentWorld.name .. "!")
                print("Starting farm...")
                
                runAllQuests(currentWorld.name, currentDragonIndex)
                
                print("\nFarming cycle complete!")
                task.wait(3)
            else
                print("\nAll quests complete in " .. currentWorld.name .. "!")
                print("Waiting 30 seconds for next world to unlock...")
                task.wait(30)
                
                local newHighestWorld = GetHighestUnlockedWorld()
                
                if newHighestWorld then
                    local newHighestOrder = tonumber(newHighestWorld.order) or 1
                    
                    if newHighestOrder > highestOrder then
                        print("New world unlocked: " .. newHighestWorld.name)
                        print("Teleporting to: " .. newHighestWorld.name)
                        TPWorld(newHighestWorld.placeId, newHighestWorld.name)
                        task.wait(15)
                    else
                        print("No new world yet, checking again...")
                        task.wait(30)
                    end
                end
            end
        end)
        
        if not success then
            warn("Error in main loop: " .. tostring(errorMsg))
            task.wait(5)
        end
    end
    task.wait(1)
end
